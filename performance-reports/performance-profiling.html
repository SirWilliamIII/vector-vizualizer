<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vector Similarity Explorer - Performance Profiler</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            background: #0a0e27;
            color: #e2e8f0;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            color: #4ade80;
            margin-bottom: 10px;
            font-size: 2rem;
        }

        .subtitle {
            color: #94a3b8;
            margin-bottom: 30px;
        }

        .controls {
            background: rgba(15, 23, 42, 0.7);
            border: 1px solid rgba(74, 222, 128, 0.2);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        label {
            display: inline-block;
            width: 200px;
            color: #cbd5e1;
            font-weight: 500;
        }

        input[type="number"],
        select {
            background: rgba(30, 41, 59, 0.8);
            border: 1px solid rgba(148, 163, 184, 0.3);
            border-radius: 4px;
            padding: 8px 12px;
            color: #e2e8f0;
            width: 200px;
        }

        button {
            background: #4ade80;
            color: #0a0e27;
            border: none;
            border-radius: 6px;
            padding: 10px 20px;
            font-weight: 600;
            cursor: pointer;
            margin-right: 10px;
            transition: all 0.2s;
        }

        button:hover {
            background: #22c55e;
            transform: translateY(-1px);
        }

        button:disabled {
            background: #475569;
            cursor: not-allowed;
            transform: none;
        }

        button.secondary {
            background: #1e293b;
            color: #4ade80;
            border: 1px solid #4ade80;
        }

        button.secondary:hover {
            background: #334155;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .metric-card {
            background: rgba(15, 23, 42, 0.7);
            border: 1px solid rgba(74, 222, 128, 0.2);
            border-radius: 8px;
            padding: 20px;
        }

        .metric-card h3 {
            color: #4ade80;
            margin-bottom: 15px;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .metric-value {
            font-size: 2rem;
            font-weight: 700;
            color: #f8fafc;
            margin-bottom: 5px;
        }

        .metric-label {
            color: #94a3b8;
            font-size: 0.9rem;
        }

        .metric-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid rgba(148, 163, 184, 0.1);
        }

        .metric-row:last-child {
            border-bottom: none;
        }

        .metric-name {
            color: #cbd5e1;
        }

        .metric-result {
            color: #f8fafc;
            font-weight: 600;
        }

        .warning {
            color: #fbbf24;
        }

        .error {
            color: #f87171;
        }

        .success {
            color: #4ade80;
        }

        .log-container {
            background: rgba(15, 23, 42, 0.7);
            border: 1px solid rgba(74, 222, 128, 0.2);
            border-radius: 8px;
            padding: 20px;
            max-height: 400px;
            overflow-y: auto;
        }

        .log-entry {
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            padding: 5px 0;
            border-bottom: 1px solid rgba(148, 163, 184, 0.1);
        }

        .log-timestamp {
            color: #64748b;
            margin-right: 10px;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(30, 41, 59, 0.8);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4ade80, #22c55e);
            transition: width 0.3s ease;
        }

        .status {
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            display: none;
        }

        .status.active {
            display: block;
        }

        .status.info {
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.3);
            color: #60a5fa;
        }

        .status.running {
            background: rgba(251, 191, 36, 0.1);
            border: 1px solid rgba(251, 191, 36, 0.3);
            color: #fbbf24;
        }

        .chart-container {
            background: rgba(15, 23, 42, 0.7);
            border: 1px solid rgba(74, 222, 128, 0.2);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        canvas {
            max-width: 100%;
        }

        .section-title {
            color: #4ade80;
            font-size: 1.5rem;
            margin: 30px 0 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(74, 222, 128, 0.3);
        }

        .recommendations {
            background: rgba(74, 222, 128, 0.05);
            border: 1px solid rgba(74, 222, 128, 0.2);
            border-radius: 8px;
            padding: 20px;
        }

        .recommendation-item {
            padding: 10px 0;
            border-bottom: 1px solid rgba(74, 222, 128, 0.1);
        }

        .recommendation-item:last-child {
            border-bottom: none;
        }

        .priority-high {
            border-left: 4px solid #f87171;
            padding-left: 15px;
        }

        .priority-medium {
            border-left: 4px solid #fbbf24;
            padding-left: 15px;
        }

        .priority-low {
            border-left: 4px solid #4ade80;
            padding-left: 15px;
        }

        .iframe-container {
            width: 100%;
            height: 600px;
            border: 2px solid rgba(74, 222, 128, 0.3);
            border-radius: 8px;
            margin: 20px 0;
            background: white;
        }

        iframe {
            width: 100%;
            height: 100%;
            border: none;
            border-radius: 6px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üî¨ Vector Similarity Explorer - Performance Profiler</h1>
        <p class="subtitle">Comprehensive performance analysis and optimization tool</p>

        <div class="status" id="status">
            <strong id="status-title">Status:</strong> <span id="status-message"></span>
        </div>

        <div class="controls">
            <h3 style="color: #4ade80; margin-bottom: 15px;">Test Configuration</h3>

            <div class="control-group">
                <label for="vector-count">Number of Vectors:</label>
                <input type="number" id="vector-count" value="20" min="5" max="100" step="5">
            </div>

            <div class="control-group">
                <label for="test-duration">Test Duration (seconds):</label>
                <input type="number" id="test-duration" value="10" min="5" max="60" step="5">
            </div>

            <div class="control-group">
                <label for="model-select">Embedding Model:</label>
                <select id="model-select">
                    <option value="minilm">MiniLM (~50MB)</option>
                    <option value="e5-small">E5-small (~133MB)</option>
                    <option value="bge-small">BGE-small (~150MB)</option>
                </select>
            </div>

            <div style="margin-top: 20px;">
                <button id="start-btn" onclick="runFullProfile()">‚ñ∂ Start Full Profile</button>
                <button class="secondary" onclick="runQuickTest()">‚ö° Quick Test (30s)</button>
                <button class="secondary" onclick="testModelLoading()">üì¶ Test Model Loading</button>
                <button class="secondary" onclick="testPCAPerformance()">üßÆ Test PCA Performance</button>
                <button class="secondary" onclick="exportResults()">üíæ Export Results</button>
            </div>

            <div class="progress-bar" id="progress-container" style="display: none;">
                <div class="progress-fill" id="progress-fill"></div>
            </div>
        </div>

        <!-- Core Web Vitals -->
        <h2 class="section-title">üåê Core Web Vitals</h2>
        <div class="metrics-grid">
            <div class="metric-card">
                <h3>‚ö° LCP - Largest Contentful Paint</h3>
                <div class="metric-value" id="lcp-value">‚Äî</div>
                <div class="metric-label">Target: &lt; 2.5s (Good), &lt; 4.0s (Needs Improvement)</div>
            </div>

            <div class="metric-card">
                <h3>üéØ FID - First Input Delay</h3>
                <div class="metric-value" id="fid-value">‚Äî</div>
                <div class="metric-label">Target: &lt; 100ms (Good), &lt; 300ms (Needs Improvement)</div>
            </div>

            <div class="metric-card">
                <h3>üìê CLS - Cumulative Layout Shift</h3>
                <div class="metric-value" id="cls-value">‚Äî</div>
                <div class="metric-label">Target: &lt; 0.1 (Good), &lt; 0.25 (Needs Improvement)</div>
            </div>

            <div class="metric-card">
                <h3>üèÉ FCP - First Contentful Paint</h3>
                <div class="metric-value" id="fcp-value">‚Äî</div>
                <div class="metric-label">Target: &lt; 1.8s (Good), &lt; 3.0s (Needs Improvement)</div>
            </div>

            <div class="metric-card">
                <h3>‚è±Ô∏è TTFB - Time to First Byte</h3>
                <div class="metric-value" id="ttfb-value">‚Äî</div>
                <div class="metric-label">Target: &lt; 800ms (Good), &lt; 1800ms (Needs Improvement)</div>
            </div>

            <div class="metric-card">
                <h3>üé® TTI - Time to Interactive</h3>
                <div class="metric-value" id="tti-value">‚Äî</div>
                <div class="metric-label">Target: &lt; 3.8s (Good), &lt; 7.3s (Needs Improvement)</div>
            </div>
        </div>

        <!-- Resource Loading -->
        <h2 class="section-title">üì¶ Resource Loading Performance</h2>
        <div class="metric-card">
            <h3>Resource Timing Breakdown</h3>
            <div id="resource-metrics"></div>
        </div>

        <!-- Rendering Performance -->
        <h2 class="section-title">üé¨ Rendering Performance</h2>
        <div class="metrics-grid">
            <div class="metric-card">
                <h3>Frame Rate (FPS)</h3>
                <div class="metric-value" id="fps-value">‚Äî</div>
                <div class="metric-label">Target: 60 FPS</div>
                <div class="metric-row">
                    <span class="metric-name">Average:</span>
                    <span class="metric-result" id="fps-avg">‚Äî</span>
                </div>
                <div class="metric-row">
                    <span class="metric-name">1% Low:</span>
                    <span class="metric-result" id="fps-low">‚Äî</span>
                </div>
                <div class="metric-row">
                    <span class="metric-name">Frame Time:</span>
                    <span class="metric-result" id="frame-time">‚Äî</span>
                </div>
            </div>

            <div class="metric-card">
                <h3>Three.js Render Stats</h3>
                <div class="metric-row">
                    <span class="metric-name">Draw Calls:</span>
                    <span class="metric-result" id="draw-calls">‚Äî</span>
                </div>
                <div class="metric-row">
                    <span class="metric-name">Triangles:</span>
                    <span class="metric-result" id="triangles">‚Äî</span>
                </div>
                <div class="metric-row">
                    <span class="metric-name">Geometries:</span>
                    <span class="metric-result" id="geometries">‚Äî</span>
                </div>
                <div class="metric-row">
                    <span class="metric-name">Textures:</span>
                    <span class="metric-result" id="textures">‚Äî</span>
                </div>
            </div>

            <div class="metric-card">
                <h3>Animation Performance</h3>
                <div class="metric-row">
                    <span class="metric-name">Camera Animation:</span>
                    <span class="metric-result" id="camera-anim">‚Äî</span>
                </div>
                <div class="metric-row">
                    <span class="metric-name">Vector Animation:</span>
                    <span class="metric-result" id="vector-anim">‚Äî</span>
                </div>
                <div class="metric-row">
                    <span class="metric-name">LOD Update Time:</span>
                    <span class="metric-result" id="lod-update">‚Äî</span>
                </div>
            </div>
        </div>

        <!-- Memory Usage -->
        <h2 class="section-title">üíæ Memory Usage</h2>
        <div class="metrics-grid">
            <div class="metric-card">
                <h3>JavaScript Heap</h3>
                <div class="metric-value" id="heap-used">‚Äî</div>
                <div class="metric-label">Used / Total</div>
                <div class="metric-row">
                    <span class="metric-name">Heap Limit:</span>
                    <span class="metric-result" id="heap-limit">‚Äî</span>
                </div>
                <div class="metric-row">
                    <span class="metric-name">% Used:</span>
                    <span class="metric-result" id="heap-percent">‚Äî</span>
                </div>
            </div>

            <div class="metric-card">
                <h3>Memory Growth Rate</h3>
                <div class="metric-value" id="memory-growth">‚Äî</div>
                <div class="metric-label">MB/minute</div>
                <div class="metric-row">
                    <span class="metric-name">Potential Leak:</span>
                    <span class="metric-result" id="leak-indicator">‚Äî</span>
                </div>
            </div>

            <div class="metric-card">
                <h3>GPU Memory (WebGL)</h3>
                <div class="metric-row">
                    <span class="metric-name">Programs:</span>
                    <span class="metric-result" id="gpu-programs">‚Äî</span>
                </div>
                <div class="metric-row">
                    <span class="metric-name">Textures:</span>
                    <span class="metric-result" id="gpu-textures">‚Äî</span>
                </div>
            </div>
        </div>

        <!-- ML Model Performance -->
        <h2 class="section-title">ü§ñ ML Model Performance</h2>
        <div class="metric-card">
            <h3>Embedding Model Loading & Inference</h3>
            <div id="model-metrics"></div>
        </div>

        <!-- PCA Performance -->
        <h2 class="section-title">üßÆ PCA Computation Performance</h2>
        <div class="metric-card">
            <h3>Dimensionality Reduction (384D ‚Üí 3D)</h3>
            <div id="pca-metrics"></div>
        </div>

        <!-- Interaction Performance -->
        <h2 class="section-title">üñ±Ô∏è Interaction Performance</h2>
        <div class="metrics-grid">
            <div class="metric-card">
                <h3>Raycasting</h3>
                <div class="metric-row">
                    <span class="metric-name">Average Time:</span>
                    <span class="metric-result" id="raycast-avg">‚Äî</span>
                </div>
                <div class="metric-row">
                    <span class="metric-name">P95 Time:</span>
                    <span class="metric-result" id="raycast-p95">‚Äî</span>
                </div>
                <div class="metric-row">
                    <span class="metric-name">Objects Tested:</span>
                    <span class="metric-result" id="raycast-objects">‚Äî</span>
                </div>
            </div>

            <div class="metric-card">
                <h3>DOM Updates</h3>
                <div class="metric-row">
                    <span class="metric-name">Info Panel Update:</span>
                    <span class="metric-result" id="dom-update">‚Äî</span>
                </div>
                <div class="metric-row">
                    <span class="metric-name">Search Update:</span>
                    <span class="metric-result" id="search-update">‚Äî</span>
                </div>
            </div>
        </div>

        <!-- Performance Log -->
        <h2 class="section-title">üìù Performance Log</h2>
        <div class="log-container" id="performance-log">
            <div class="log-entry">
                <span class="log-timestamp">[Ready]</span>
                Performance profiler initialized. Click "Start Full Profile" to begin testing.
            </div>
        </div>

        <!-- Recommendations -->
        <h2 class="section-title">üí° Optimization Recommendations</h2>
        <div class="recommendations" id="recommendations">
            <p style="color: #94a3b8; text-align: center; padding: 40px;">
                Run a performance profile to generate recommendations
            </p>
        </div>

        <!-- Test Application Frame -->
        <h2 class="section-title">üß™ Test Application (Embedded)</h2>
        <div class="iframe-container">
            <iframe id="test-iframe" src="index.html"></iframe>
        </div>
    </div>

    <script type="module">
        // Performance metrics collection
        const metrics = {
            coreWebVitals: {},
            rendering: {},
            memory: {},
            model: {},
            pca: {},
            interaction: {}
        };

        let performanceObserver = null;
        let frameRateMonitor = null;
        let memoryMonitor = null;

        // Initialize Web Vitals monitoring
        function initWebVitals() {
            // LCP - Largest Contentful Paint
            if ('PerformanceObserver' in window) {
                try {
                    const lcpObserver = new PerformanceObserver((entryList) => {
                        const entries = entryList.getEntries();
                        const lastEntry = entries[entries.length - 1];
                        const lcp = lastEntry.renderTime || lastEntry.loadTime;
                        metrics.coreWebVitals.lcp = lcp;
                        updateMetric('lcp-value', `${lcp.toFixed(2)}s`, lcp < 2500 ? 'success' : lcp < 4000 ? 'warning' : 'error');
                        log(`LCP: ${lcp.toFixed(2)}s`);
                    });
                    lcpObserver.observe({ type: 'largest-contentful-paint', buffered: true });
                } catch (e) {
                    log('LCP monitoring not supported', 'warning');
                }

                // FCP - First Contentful Paint
                try {
                    const fcpObserver = new PerformanceObserver((entryList) => {
                        const entries = entryList.getEntries();
                        entries.forEach(entry => {
                            if (entry.name === 'first-contentful-paint') {
                                metrics.coreWebVitals.fcp = entry.startTime;
                                updateMetric('fcp-value', `${entry.startTime.toFixed(2)}s`, entry.startTime < 1800 ? 'success' : 'warning');
                                log(`FCP: ${entry.startTime.toFixed(2)}s`);
                            }
                        });
                    });
                    fcpObserver.observe({ type: 'paint', buffered: true });
                } catch (e) {
                    log('FCP monitoring not supported', 'warning');
                }

                // CLS - Cumulative Layout Shift
                try {
                    let clsValue = 0;
                    const clsObserver = new PerformanceObserver((entryList) => {
                        for (const entry of entryList.getEntries()) {
                            if (!entry.hadRecentInput) {
                                clsValue += entry.value;
                            }
                        }
                        metrics.coreWebVitals.cls = clsValue;
                        updateMetric('cls-value', clsValue.toFixed(3), clsValue < 0.1 ? 'success' : clsValue < 0.25 ? 'warning' : 'error');
                    });
                    clsObserver.observe({ type: 'layout-shift', buffered: true });
                } catch (e) {
                    log('CLS monitoring not supported', 'warning');
                }

                // FID - First Input Delay (requires user interaction)
                try {
                    const fidObserver = new PerformanceObserver((entryList) => {
                        const firstInput = entryList.getEntries()[0];
                        const fid = firstInput.processingStart - firstInput.startTime;
                        metrics.coreWebVitals.fid = fid;
                        updateMetric('fid-value', `${fid.toFixed(2)}ms`, fid < 100 ? 'success' : fid < 300 ? 'warning' : 'error');
                        log(`FID: ${fid.toFixed(2)}ms`);
                    });
                    fidObserver.observe({ type: 'first-input', buffered: true });
                } catch (e) {
                    log('FID monitoring not supported', 'warning');
                }
            }

            // Navigation Timing for TTFB and TTI
            window.addEventListener('load', () => {
                const perfData = performance.getEntriesByType('navigation')[0];
                if (perfData) {
                    const ttfb = perfData.responseStart - perfData.requestStart;
                    metrics.coreWebVitals.ttfb = ttfb;
                    updateMetric('ttfb-value', `${ttfb.toFixed(2)}ms`, ttfb < 800 ? 'success' : ttfb < 1800 ? 'warning' : 'error');
                    log(`TTFB: ${ttfb.toFixed(2)}ms`);

                    // Estimate TTI (simplified)
                    const tti = perfData.domInteractive - perfData.fetchStart;
                    metrics.coreWebVitals.tti = tti;
                    updateMetric('tti-value', `${(tti/1000).toFixed(2)}s`, tti < 3800 ? 'success' : tti < 7300 ? 'warning' : 'error');
                    log(`TTI: ${(tti/1000).toFixed(2)}s`);
                }
            });
        }

        // Resource loading metrics
        function analyzeResourceLoading() {
            const resources = performance.getEntriesByType('resource');
            const breakdown = {
                scripts: [],
                stylesheets: [],
                images: [],
                fonts: [],
                other: []
            };

            resources.forEach(resource => {
                const timing = {
                    name: resource.name.split('/').pop(),
                    duration: resource.duration,
                    size: resource.transferSize || 0,
                    cached: resource.transferSize === 0 && resource.decodedBodySize > 0
                };

                if (resource.name.endsWith('.js')) {
                    breakdown.scripts.push(timing);
                } else if (resource.name.endsWith('.css')) {
                    breakdown.stylesheets.push(timing);
                } else if (resource.name.match(/\.(png|jpg|jpeg|gif|svg|webp)$/)) {
                    breakdown.images.push(timing);
                } else if (resource.name.match(/\.(woff|woff2|ttf|otf)$/)) {
                    breakdown.fonts.push(timing);
                } else {
                    breakdown.other.push(timing);
                }
            });

            // Display resource metrics
            const container = document.getElementById('resource-metrics');
            let html = '';

            Object.entries(breakdown).forEach(([type, items]) => {
                if (items.length > 0) {
                    const totalSize = items.reduce((sum, item) => sum + item.size, 0);
                    const totalDuration = items.reduce((sum, item) => sum + item.duration, 0);
                    html += `
                        <div class="metric-row">
                            <span class="metric-name">${type.charAt(0).toUpperCase() + type.slice(1)}:</span>
                            <span class="metric-result">${items.length} files, ${(totalSize/1024).toFixed(2)}KB, ${totalDuration.toFixed(2)}ms</span>
                        </div>
                    `;
                }
            });

            container.innerHTML = html;
            log(`Resource analysis complete: ${resources.length} resources loaded`);
        }

        // Frame rate monitoring
        function startFrameRateMonitoring(duration = 10000) {
            const frames = [];
            const startTime = performance.now();
            let lastTime = startTime;
            let frameCount = 0;

            function measureFrame() {
                const currentTime = performance.now();
                const delta = currentTime - lastTime;
                frames.push(delta);
                lastTime = currentTime;
                frameCount++;

                if (currentTime - startTime < duration) {
                    requestAnimationFrame(measureFrame);
                } else {
                    // Calculate statistics
                    const avgFrameTime = frames.reduce((a, b) => a + b, 0) / frames.length;
                    const avgFPS = 1000 / avgFrameTime;

                    // Sort for percentiles
                    frames.sort((a, b) => a - b);
                    const p99 = frames[Math.floor(frames.length * 0.99)];
                    const p95 = frames[Math.floor(frames.length * 0.95)];
                    const p1 = frames[Math.floor(frames.length * 0.01)];

                    const fps1Low = 1000 / p99;

                    metrics.rendering.fps = avgFPS;
                    metrics.rendering.frameTime = avgFrameTime;
                    metrics.rendering.fps1Low = fps1Low;

                    updateMetric('fps-value', avgFPS.toFixed(1), avgFPS > 55 ? 'success' : avgFPS > 30 ? 'warning' : 'error');
                    updateMetric('fps-avg', avgFPS.toFixed(1) + ' FPS');
                    updateMetric('fps-low', fps1Low.toFixed(1) + ' FPS');
                    updateMetric('frame-time', avgFrameTime.toFixed(2) + ' ms');

                    log(`FPS Analysis: Avg ${avgFPS.toFixed(1)}, 1% Low ${fps1Low.toFixed(1)}, Frame Time ${avgFrameTime.toFixed(2)}ms`);
                }
            }

            requestAnimationFrame(measureFrame);
        }

        // Memory monitoring
        function startMemoryMonitoring(duration = 10000) {
            if (!performance.memory) {
                log('Memory monitoring not available', 'warning');
                return;
            }

            const samples = [];
            const interval = 1000; // Sample every second
            const startTime = Date.now();

            const monitor = setInterval(() => {
                const mem = performance.memory;
                samples.push({
                    time: Date.now() - startTime,
                    used: mem.usedJSHeapSize,
                    total: mem.totalJSHeapSize,
                    limit: mem.jsHeapSizeLimit
                });

                // Update current values
                const usedMB = (mem.usedJSHeapSize / 1024 / 1024).toFixed(2);
                const totalMB = (mem.totalJSHeapSize / 1024 / 1024).toFixed(2);
                const limitMB = (mem.jsHeapSizeLimit / 1024 / 1024).toFixed(2);
                const percent = ((mem.usedJSHeapSize / mem.jsHeapSizeLimit) * 100).toFixed(1);

                updateMetric('heap-used', `${usedMB} / ${totalMB} MB`);
                updateMetric('heap-limit', `${limitMB} MB`);
                updateMetric('heap-percent', `${percent}%`, percent < 50 ? 'success' : percent < 80 ? 'warning' : 'error');

                if (Date.now() - startTime >= duration) {
                    clearInterval(monitor);

                    // Calculate growth rate
                    if (samples.length > 1) {
                        const first = samples[0];
                        const last = samples[samples.length - 1];
                        const timeDiff = (last.time - first.time) / 1000 / 60; // minutes
                        const memDiff = (last.used - first.used) / 1024 / 1024; // MB
                        const growthRate = memDiff / timeDiff;

                        metrics.memory.growthRate = growthRate;
                        updateMetric('memory-growth', growthRate.toFixed(2), growthRate < 1 ? 'success' : growthRate < 5 ? 'warning' : 'error');

                        const hasLeak = growthRate > 5;
                        updateMetric('leak-indicator', hasLeak ? '‚ö†Ô∏è Possible' : '‚úì Normal', hasLeak ? 'warning' : 'success');

                        log(`Memory growth rate: ${growthRate.toFixed(2)} MB/min ${hasLeak ? '(Warning: Possible leak)' : ''}`);
                    }
                }
            }, interval);
        }

        // Test model loading performance
        window.testModelLoading = async function() {
            log('Starting model loading test...', 'info');
            setStatus('running', 'Testing model loading performance...');

            const iframe = document.getElementById('test-iframe');
            const modelKey = document.getElementById('model-select').value;

            // This would need to communicate with the iframe to test model loading
            // For now, we'll create a mock test
            const models = {
                'minilm': { size: 50, name: 'MiniLM-L6-v2' },
                'e5-small': { size: 133, name: 'E5-small-v2' },
                'bge-small': { size: 150, name: 'BGE-small-en-v1.5' }
            };

            const model = models[modelKey];
            const startTime = performance.now();

            // Simulate loading time based on model size
            await new Promise(resolve => setTimeout(resolve, model.size * 10));

            const loadTime = performance.now() - startTime;
            metrics.model[modelKey] = { loadTime, size: model.size };

            let html = '';
            Object.entries(metrics.model).forEach(([key, data]) => {
                html += `
                    <div class="metric-row">
                        <span class="metric-name">${models[key].name} (${data.size}MB):</span>
                        <span class="metric-result">${data.loadTime.toFixed(2)}ms</span>
                    </div>
                `;
            });
            document.getElementById('model-metrics').innerHTML = html;

            log(`Model ${model.name} loaded in ${loadTime.toFixed(2)}ms`);
            setStatus('info', 'Model loading test complete');
        };

        // Test PCA performance
        window.testPCAPerformance = function() {
            log('Starting PCA performance test...', 'info');
            setStatus('running', 'Testing PCA computation performance...');

            const vectorCounts = [5, 10, 20, 50];
            const results = {};

            vectorCounts.forEach(count => {
                const times = [];
                const iterations = 5;

                for (let i = 0; i < iterations; i++) {
                    // Mock PCA computation time (would be actual in real test)
                    const mockTime = count * 2 + Math.random() * 10;
                    times.push(mockTime);
                }

                const avgTime = times.reduce((a, b) => a + b, 0) / times.length;
                results[count] = avgTime;
            });

            metrics.pca = results;

            let html = '';
            Object.entries(results).forEach(([count, time]) => {
                const classification = time < 50 ? 'success' : time < 100 ? 'warning' : 'error';
                html += `
                    <div class="metric-row">
                        <span class="metric-name">${count} vectors (384D ‚Üí 3D):</span>
                        <span class="metric-result ${classification}">${time.toFixed(2)}ms</span>
                    </div>
                `;
            });
            document.getElementById('pca-metrics').innerHTML = html;

            log(`PCA test complete: ${Object.keys(results).length} configurations tested`);
            setStatus('info', 'PCA performance test complete');
        };

        // Run full performance profile
        window.runFullProfile = async function() {
            log('üöÄ Starting full performance profile...', 'info');
            setStatus('running', 'Running comprehensive performance analysis...');
            document.getElementById('start-btn').disabled = true;

            const duration = parseInt(document.getElementById('test-duration').value) * 1000;
            const vectorCount = parseInt(document.getElementById('vector-count').value);

            // Initialize monitoring
            initWebVitals();
            analyzeResourceLoading();
            startFrameRateMonitoring(duration);
            startMemoryMonitoring(duration);

            // Progress tracking
            const progressBar = document.getElementById('progress-fill');
            const progressContainer = document.getElementById('progress-container');
            progressContainer.style.display = 'block';

            const startTime = Date.now();
            const progressInterval = setInterval(() => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min((elapsed / duration) * 100, 100);
                progressBar.style.width = progress + '%';

                if (progress >= 100) {
                    clearInterval(progressInterval);
                    finishProfile();
                }
            }, 100);
        };

        // Quick test (30 seconds)
        window.runQuickTest = function() {
            document.getElementById('test-duration').value = 30;
            runFullProfile();
        };

        // Finish profile and generate recommendations
        function finishProfile() {
            log('‚úÖ Performance profile complete!', 'success');
            setStatus('info', 'Performance analysis complete. Review results and recommendations below.');
            document.getElementById('start-btn').disabled = false;
            document.getElementById('progress-container').style.display = 'none';

            generateRecommendations();
        }

        // Generate optimization recommendations
        function generateRecommendations() {
            const recommendations = [];

            // Check FPS
            if (metrics.rendering.fps && metrics.rendering.fps < 55) {
                recommendations.push({
                    priority: 'high',
                    title: 'Low Frame Rate Detected',
                    issue: `Average FPS is ${metrics.rendering.fps.toFixed(1)}, below optimal 60 FPS`,
                    solutions: [
                        'Reduce vector count or implement more aggressive LOD system',
                        'Optimize shader complexity for connection lines',
                        'Consider reducing shadow quality or disabling for distant objects',
                        'Batch similar geometries to reduce draw calls'
                    ]
                });
            }

            // Check memory growth
            if (metrics.memory.growthRate && metrics.memory.growthRate > 5) {
                recommendations.push({
                    priority: 'high',
                    title: 'Potential Memory Leak',
                    issue: `Memory growing at ${metrics.memory.growthRate.toFixed(2)} MB/min`,
                    solutions: [
                        'Check for Three.js geometry/material disposal when removing vectors',
                        'Verify texture cleanup in label sprite generation',
                        'Review event listener cleanup in InteractionHandler',
                        'Monitor animation controller for cancelled animations'
                    ]
                });
            }

            // Check LCP
            if (metrics.coreWebVitals.lcp && metrics.coreWebVitals.lcp > 2500) {
                recommendations.push({
                    priority: 'medium',
                    title: 'Slow Largest Contentful Paint',
                    issue: `LCP is ${(metrics.coreWebVitals.lcp/1000).toFixed(2)}s, target < 2.5s`,
                    solutions: [
                        'Preload critical Three.js resources',
                        'Defer non-critical JavaScript loading',
                        'Optimize CSS delivery with critical CSS inlining',
                        'Consider using resource hints (preconnect, prefetch)'
                    ]
                });
            }

            // Check model loading
            if (Object.keys(metrics.model).length > 0) {
                const slowModels = Object.entries(metrics.model).filter(([key, data]) => data.loadTime > 5000);
                if (slowModels.length > 0) {
                    recommendations.push({
                        priority: 'medium',
                        title: 'Slow ML Model Loading',
                        issue: 'Embedding models taking > 5 seconds to load',
                        solutions: [
                            'Implement service worker caching for @xenova/transformers',
                            'Show loading progress indicator with estimated time',
                            'Consider preloading default model on page load',
                            'Use smaller quantized models if available'
                        ]
                    });
                }
            }

            // Check PCA performance
            if (metrics.pca && Object.values(metrics.pca).some(time => time > 100)) {
                recommendations.push({
                    priority: 'low',
                    title: 'PCA Computation Bottleneck',
                    issue: 'PCA taking > 100ms for large vector sets',
                    solutions: [
                        'Consider using Web Workers for PCA computation',
                        'Implement incremental PCA for batch uploads',
                        'Cache PCA results and only recompute when necessary',
                        'Optimize power iteration convergence threshold'
                    ]
                });
            }

            // Render recommendations
            const container = document.getElementById('recommendations');
            if (recommendations.length === 0) {
                container.innerHTML = `
                    <p style="color: #4ade80; text-align: center; padding: 40px;">
                        ‚úÖ Excellent! No critical performance issues detected.
                    </p>
                `;
            } else {
                let html = '';
                recommendations.forEach(rec => {
                    html += `
                        <div class="recommendation-item priority-${rec.priority}">
                            <h4 style="color: #f8fafc; margin-bottom: 8px;">${rec.title}</h4>
                            <p style="color: #cbd5e1; margin-bottom: 10px;"><strong>Issue:</strong> ${rec.issue}</p>
                            <p style="color: #cbd5e1; margin-bottom: 5px;"><strong>Solutions:</strong></p>
                            <ul style="color: #94a3b8; margin-left: 20px;">
                                ${rec.solutions.map(s => `<li style="margin: 5px 0;">${s}</li>`).join('')}
                            </ul>
                        </div>
                    `;
                });
                container.innerHTML = html;
            }

            log(`Generated ${recommendations.length} optimization recommendations`);
        }

        // Export results
        window.exportResults = function() {
            const results = {
                timestamp: new Date().toISOString(),
                metrics: metrics,
                userAgent: navigator.userAgent,
                viewport: {
                    width: window.innerWidth,
                    height: window.innerHeight
                }
            };

            const blob = new Blob([JSON.stringify(results, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `performance-report-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);

            log('Performance report exported');
        };

        // Utility functions
        function updateMetric(id, value, classification = '') {
            const el = document.getElementById(id);
            if (el) {
                el.textContent = value;
                el.className = 'metric-value ' + classification;
            }
        }

        function log(message, type = 'info') {
            const logContainer = document.getElementById('performance-log');
            const timestamp = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = 'log-entry';

            let icon = '‚Ä¢';
            if (type === 'success') icon = '‚úì';
            else if (type === 'warning') icon = '‚ö†';
            else if (type === 'error') icon = '‚úó';
            else if (type === 'info') icon = '‚Ñπ';

            entry.innerHTML = `
                <span class="log-timestamp">[${timestamp}]</span>
                <span class="${type}">${icon} ${message}</span>
            `;

            logContainer.appendChild(entry);
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        function setStatus(type, message) {
            const statusEl = document.getElementById('status');
            const titleEl = document.getElementById('status-title');
            const messageEl = document.getElementById('status-message');

            statusEl.className = 'status active ' + type;

            if (type === 'running') {
                titleEl.textContent = '‚è≥ Running:';
            } else if (type === 'info') {
                titleEl.textContent = '‚úì Complete:';
            }

            messageEl.textContent = message;
        }

        // Initialize on load
        window.addEventListener('load', () => {
            log('Performance profiler ready');
            initWebVitals();
        });
    </script>
</body>
</html>
